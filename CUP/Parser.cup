package Parser;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import AST.*;

/* ------------- TERMINALS ------------- */

terminal            WHILE, IF, ELSE, FUNC, OUTPUT, INPUT, RETURN; /* while, if, else, func, intput(), output() */
terminal            LPAREN, RPAREN, LCURL, RCURL, COMMA, SEMICOLON; /* ( ) { } , ; */
terminal            AND, OR, NOT;
terminal            SUM, SUB, MULT, DIV, MOD; /* +, -, *, /, %  */
terminal            GE, LE, GT, LT, NE, EQ; /* >=, <=, >, <, !=, == */
terminal            ASSIGN; /* = */
terminal Integer    INT_LIT; /* 42 */
terminal String     STR_LIT; /* "hola" */
terminal Boolean    BOOL_LIT; /* true, false */  
terminal            UNARI_SUB;
terminal String     ID; /* hola */
terminal String     STR_TYPE, INT_TYPE, VOID_TYPE, BOOL_TYPE; /* string, int, void, bool */

non terminal Node     Program, Function, FunctionList;
non terminal Node     Arg, Args;
non terminal Node     Block, Statement, StatementList;
non terminal Node     Loop, Conditional, Declaration, Instruction;
non terminal Node     WhileLoop;
non terminal Node     IfCondition;
non terminal Node     Assignation;
non terminal Node     Expr, BinOp, UnOp, UnExpr, Primary, ExprList, ExprArg;
non terminal String   TypeFunc, TypeVar;

precedence left SUM, SUB;
precedence left MULT, DIV, MOD;
precedence right UNARI_SUB;

precedence left OR;
precedence left AND;
precedence right NOT;

/* ------------- SYNTACTIC GRAMMAR RULES ------------- */

start with Program;

Program     ::=   FunctionList:fl
                    {: RESULT = new Program((FunctionList) fl); RESULT.toDot(); :}
                | error
                ;

TypeFunc    ::=   BOOL_TYPE:t
                    {: System.out.println("Reducido type bool: "+t); RESULT = t; :}
                | STR_TYPE:t
                     {: System.out.println("Reducido type str: "+t); RESULT = t; :}
                | INT_TYPE:t
                    {: System.out.println("Reducido type int: "+t); RESULT = t; :}
                | VOID_TYPE:t
                    {: System.out.println("Reducido type void: "+t); RESULT = t; :}
                ;

TypeVar     ::=   BOOL_TYPE 
                | STR_TYPE
                | INT_TYPE
                ;

FunctionList ::=   Function:f FunctionList:fl
                    {: RESULT = new FunctionList((Function)f, (FunctionList)fl); RESULT.toDot(); :}
                 | Function:f
                    {: RESULT = new FunctionList((Function)f, null); RESULT.toDot(); :}
                 ;

Function    ::=   FUNC TypeFunc:t ID:id LPAREN Args:args RPAREN LCURL Block:b RCURL
                    {: System.out.println("reducido Function: "+t); RESULT = new Function(t,id,(Args)args,(Block)b); RESULT.toDot(); :}
                ;

Args        ::= | 
                   Arg
                    {: RESULT = new Args(); RESULT.toDot(); :} 
                |  Arg COMMA Args
                    {: RESULT = new Args(); RESULT.toDot(); :}
                ;

Arg         ::=   TypeVar ID;



Block       ::=   StatementList
                    {: RESULT = new Block(); RESULT.toDot(); :}
                ;

StatementList ::=   Statement StatementList
                  |
                  ;

Statement   ::=   Loop 
                | Conditional
                | Instruction SEMICOLON
                ;


Loop        ::=   WhileLoop;
Conditional ::=   IfCondition;

WhileLoop   ::=   WHILE LPAREN Expr RPAREN LCURL Block RCURL;
IfCondition ::=   IF LPAREN Expr RPAREN LCURL Block RCURL
                | IF LPAREN Expr RPAREN LCURL Block RCURL ELSE LCURL Block RCURL
                ;

Instruction ::=   ID LPAREN ExprArg RPAREN // Llamada a funcion foo(arg1, arg2, ...)
                | INPUT LPAREN RPAREN   // input(var)
                | OUTPUT LPAREN Expr RPAREN  // output(bla)
                | RETURN Expr           // return bla
                | Assignation           // lhs = rhs
                | Declaration           // type lhs = rhs; type lhs2;
                ;

ExprArg     ::=   | Expr ExprList;
ExprList    ::=   | COMMA Expr ExprList;

Declaration ::=   TypeVar ID 
                | TypeVar Assignation  
                ;

Assignation ::=   ID ASSIGN Expr
                ;

/* EXPRESIONES ARITMETICOLÃ“GICAS */
Expr        ::=   UnExpr 
                | Expr BinOp UnExpr
                ;
UnExpr      ::=   UnOp UnExpr
                | Primary
                ;

BinOp       ::=   OR
                | AND 
                | SUM
                | SUB 
                | MULT 
                | DIV 
                | MOD 
                | GT 
                | LT 
                | GE 
                | LE
                | EQ
                | NE
                ;

UnOp        ::=   SUB %prec UNARI_SUB
                | NOT 
                ;

Primary     ::=   LPAREN Expr RPAREN // ( ID )
                | ID LPAREN ExprArg RPAREN // llamada a funcion que devuelva valor: getVal(x,y)
                | ID 
                | INT_LIT
                | STR_LIT
                | BOOL_LIT
                ;