package Parser;
import java_cup.runtime.*;


/* ------------- TERMINALS ------------- */

terminal            STR_TYPE, INT_TYPE, VOID_TYPE, BOOL_TYPE; /* string, int, void, bool */
terminal            WHILE, IF, ELSE, FUNC, OUTPUT, INPUT, RETURN; /* while, if, else, func, intput(), output() */
terminal            LPAREN, RPAREN, LCURL, RCURL, COMMA, SEMICOLON; /* ( ) { } , ; */
terminal            AND, OR, NOT;
terminal            SUM, SUB, MULT, DIV, MOD; /* +, -, *, /, %  */
terminal            GE, LE, GT, LT, NE, EQ; /* >=, <=, >, <, !=, == */
terminal            ASSIGN; /* = */
terminal Integer    ID; /* hola */
terminal Integer    INT_LIT; /* 42 */
terminal String     STR_LIT; /* "hola" */
terminal Boolean    BOOL_LIT; /* true, false */  
terminal            UNARI_SUB;


non terminal Object     Program, Function, FunctionList;
non terminal Object     TypeFunc, TypeVar;
non terminal Object     Arg, Args;
non terminal Object     Block, Statement, StatementList;
non terminal Object     Loop, Conditional, Declaration, Instruction;
non terminal Object     WhileLoop;
non terminal Object     IfCondition;
non terminal Object     Assignation;
non terminal Object     Expr, BinOp, UnOp, UnExpr, Primary, ExprList, ExprArg;

precedence left SUM, SUB;
precedence left MULT, DIV, MOD;
precedence right UNARI_SUB;

precedence left OR;
precedence left AND;
precedence right NOT;

/* ------------- SYNTACTIC GRAMMAR RULES ------------- */

/* Gramatica de expresiones logicas + comparaciones de enteros (i.e. todo lo que devuelva bool) */

start with Program;

Program     ::=   FunctionList
                | error
                ;

TypeFunc    ::=   BOOL_TYPE 
                | STR_TYPE
                | INT_TYPE
                | VOID_TYPE
                ;

TypeVar     ::=   BOOL_TYPE 
                | STR_TYPE
                | INT_TYPE
                ;

FunctionList ::=   Function FunctionList
                 | Function
                 ;

Function    ::=   FUNC TypeFunc ID LPAREN Args RPAREN LCURL Block RCURL;

Args        ::=   | Arg | Arg COMMA Args;
Arg         ::=   TypeVar ID;



Block       ::=   StatementList;

StatementList ::=   Statement StatementList
                  |
                  ;

Statement   ::=   Loop 
                | Conditional
                | Instruction SEMICOLON
                ;


Loop        ::=   WhileLoop;
Conditional ::=   IfCondition;

WhileLoop   ::=   WHILE LPAREN Expr RPAREN LCURL Block RCURL;
IfCondition ::=   IF LPAREN Expr RPAREN LCURL Block RCURL
                | IF LPAREN Expr RPAREN LCURL Block RCURL ELSE LCURL Block RCURL
                ;

Instruction ::=   ID LPAREN ExprArg RPAREN // Llamada a funcion foo(arg1, arg2, ...)
                | INPUT LPAREN RPAREN   // input(var)
                | OUTPUT LPAREN Expr RPAREN  // output(bla)
                | RETURN Expr           // return bla
                | Assignation           // lhs = rhs
                | Declaration           // type lhs = rhs; type lhs2;
                ;

ExprArg     ::=   | Expr ExprList;
ExprList    ::=   | COMMA Expr ExprList;

Declaration ::=   TypeVar ID 
                | TypeVar Assignation  
                ;

Assignation ::=   ID ASSIGN Expr
                ;

/* EXPRESIONES ARITMETICOLÃ“GICAS */
Expr        ::=   UnExpr 
                | Expr BinOp UnExpr
                ;
UnExpr      ::=   UnOp UnExpr
                | Primary
                ;

BinOp       ::=   OR
                | AND 
                | SUM
                | SUB 
                | MULT 
                | DIV 
                | MOD 
                | GT 
                | LT 
                | GE 
                | LE
                | EQ
                | NE
                ;

UnOp        ::=   SUB %prec UNARI_SUB
                | NOT 
                ;

Primary     ::=   LPAREN Expr RPAREN // ( ID )
                | ID LPAREN ExprArg RPAREN // llamada a funcion que devuelva valor: getVal(x,y)
                | ID 
                | INT_LIT
                | STR_LIT
                | BOOL_LIT
                ;